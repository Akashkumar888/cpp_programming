
class Solution {
  public:
  void solve(int i,int n,vector<int>&arr,map<int,string>&mp,string &str,vector<string>&result){
      if(i>=n){
          result.push_back(str);
          return;
      }
      int idx=arr[i];
      
      if(mp[idx].empty()){ // skip 0 and 1
            solve(i+1,n,arr,mp,str,result);
            return;
        }
      for(char &ch:mp[idx]){
          str.push_back(ch);// do char push in str 
          solve(i+1,n,arr,mp,str,result);// explore
          str.pop_back();// undo
      }
  }
    vector<string> possibleWords(vector<int> &arr) {
        // code here
        // list all possible words in any order
        //which can be generated by pressing numbers in arr[] sequentially
        // Number 0 and 1 do not map to any letters.
        vector<string>result;
        int n=arr.size();
        map<int,string>mp;
        mp[0]="";
        mp[1]="";
        mp[2]="abc";
        mp[3]="def";
        mp[4]="ghi";
        mp[5]="jkl";
        mp[6]="mno";
        mp[7]="pqrs";
        mp[8]="tuv";
        mp[9]="wxyz";
        string str="";
        solve(0,n,arr,mp,str,result);
        return result;
    }
};

class Solution {
  public:
  void solve(int i,int n,vector<int>&arr,map<int,string>&mp,string &str,vector<string>&result){
      if(i>=n){
          result.push_back(str);
          return;
      }
      int idx=arr[i];
      if(idx==0 || idx==1){ // skip invalid keys
          solve(i+1,n,arr,mp,str,result);  // just skip 0 and 1
          return;
      }
      for(char &ch:mp[idx]){
          str.push_back(ch);// do char push in str 
          solve(i+1,n,arr,mp,str,result);// explore
          str.pop_back();// undo
      }
  }
    vector<string> possibleWords(vector<int> &arr) {
        // code here
        // list all possible words in any order
        //which can be generated by pressing numbers in arr[] sequentially
        // Number 0 and 1 do not map to any letters.
        //vector<string> mp = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        vector<string>result;
        int n=arr.size();
        map<int,string>mp;
        mp[2]="abc";
        mp[3]="def";
        mp[4]="ghi";
        mp[5]="jkl";
        mp[6]="mno";
        mp[7]="pqrs";
        mp[8]="tuv";
        mp[9]="wxyz";
        string str="";
        solve(0,n,arr,mp,str,result);
        return result;
    }
};


class Solution {
  public:
  void solve(int i,int n,vector<int>&arr,vector<string>&mp,string &str,vector<string>&result){
      if(i>=n){
          result.push_back(str);
          return;
      }
      int idx=arr[i];
    //   if(mp[idx].empty()){ // skip 0 and 1
    //         solve(i+1,n,arr,mp,str,result);
    //         return;
    //     }
        if(mp[idx]==""){ // skip 0 and 1
            solve(i+1,n,arr,mp,str,result);
            return;
        }
      for(char &ch:mp[idx]){
          str.push_back(ch);// do char push in str 
          solve(i+1,n,arr,mp,str,result);// explore
          str.pop_back();// undo
      }
  }
    vector<string> possibleWords(vector<int> &arr) {
        // code here
        // list all possible words in any order
        //which can be generated by pressing numbers in arr[] sequentially
        // Number 0 and 1 do not map to any letters.
        vector<string>result;
        int n=arr.size();
        string str="";
        vector<string> mp = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        solve(0,n,arr,mp,str,result);
        return result;
    }
};

class Solution {
  public:
  void solve(int i,int n,vector<int>&arr,vector<string>&mp,string &str,vector<string>&result){
      if(i>=n){
          result.push_back(str);
          return;
      }
      int idx=arr[i];
      if(idx==0 || idx==1){ // skip invalid keys
          solve(i+1,n,arr,mp,str,result);  // just skip 0 and 1
          return;
      }
      for(char &ch:mp[idx]){
          str.push_back(ch);// do char push in str 
          solve(i+1,n,arr,mp,str,result);// explore
          str.pop_back();// undo
      }
  }
    vector<string> possibleWords(vector<int> &arr) {
        // code here
        // list all possible words in any order
        //which can be generated by pressing numbers in arr[] sequentially
        // Number 0 and 1 do not map to any letters.
        vector<string>result;
        int n=arr.size();
        string str="";
        vector<string> mp = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        solve(0,n,arr,mp,str,result);
        return result;
    }
};

class Solution {
public:
void solve(int i,string &temp,string &digits,unordered_map<char,string>&mp,vector<string>&ans){
if(i>=digits.size()){
    ans.push_back(temp);
    return ;
}
char ch=digits[i];
for(char &ch:mp[ch]){
    temp.push_back(ch);
    solve(i+1,temp,digits,mp,ans);
    temp.pop_back();
}
}
    vector<string> letterCombinations(string digits) {
    if(digits.size()==0)return {};
      vector<string>ans;
      unordered_map<char,string>mp;
      mp['2']="abc";
      mp['3']="def";
      mp['4']="ghi";
      mp['5']="jkl";
      mp['6']="mno";
      mp['7']="pqrs";
      mp['8']="tuv";
      mp['9']="wxyz";  
      string temp="";
      solve(0,temp,digits,mp,ans);
      return ans;
    }
};

class Solution {
public:
void solve(int i,string &temp,string &digits,vector<string>&mp,vector<string>&ans){
if(i>=digits.size()){
    ans.push_back(temp);
    return ;
}
char ch=digits[i];
for(char &ch:mp[ch-'2']){
    temp.push_back(ch);
    solve(i+1,temp,digits,mp,ans);
    temp.pop_back();
}
}
    vector<string> letterCombinations(string digits) {
    if(digits.size()==0)return {};
      vector<string>ans;
      vector<string> mp = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}; 
      string temp="";
      solve(0,temp,digits,mp,ans);
      return ans;
    }
};


// ðŸ“Š Complexity (all versions)
// Time: O(k^n) where k = max letters per digit (3â€“4), n = number of digits.
// Space:
// Recursion depth O(n).
// Result storage O(k^n * n).